# 模块包基础

## 导入模块包

代码：

```Python
import dir1.dir2.mod
from dir1.dir2.mod import x
```

其中点号相当于路径。

**不可以使用斜杠或其他路径写法。**

这些都是错误的写法。

```Python
import dir1/dir2/mod  # 错误
import C:\mycode\mod  # 错误
import ../mod         # 错误
```

## \_\_init\_\_.py 包文件

模块包内必须含有一个 `__init__.py` 文件，否则无法导入模块包。

`__init__.py` 文件可以为空。

对于多层的模块包，如 `dir0/dir1/dir2/mod.py` 其中主程序在 `dir0` 目录内，此时要导入模块包，需要以下几个条件：

* `dir1` 和 `dir2` 中都必须有一个 `__init__.py` 文件。

* `dir0` 是容器，不需要有 `__init__.py` 文件，如果有的话，也会被忽略。

* `dir0` 必须位于模块搜索路径中（详见22章模块搜索路径）

**\_\_init\_\_.py 文件的作用**

* 防止模块搜索路径中存在与模块包相同名称的目录，从而导致加载到别的目录

* 作为包初始化的钩子、替目录产生模块命名空间、使用目录导入时实现 `from *` 行为

包的初始化
: 首次导入某个目录时，会自动执行该目录下的 `__init__.py` 文件中的代码。例如，可以使用初始化文件，创建所需要的数据文件、连接数据库等。

模块命名空间的初始化
: 在包导入的模型中，脚本内的目录，在导入后会变成真实的嵌套对象路径。

`from *` 语句的行为
: 可以在 `__init__.py` 文件中，使用 `__all__` 列表来定义目录以 `from *` 语句导入时，需要导出什么。
`__all__` 列表指：当包使用 `from *` 时，应该导入的子模块的名称清单。
如果没有设定 `__all__`，`from *` 不会自动加载嵌套与该目录内的子模块。取而代之的是，只加载该目录的 `__inti__.py` 文件中赋值语句定义的变量名，包括该文件中程序代码明确导入的任何子模块
