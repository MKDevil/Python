# 异常基础

## 常用异常语句

try/except
: 捕捉由 Python 或你引起的异常并恢复

try/finally
: 无论异常是否发生，执行清理行为

raise
: 手动在代码中触发异常

assert
: 有条件的在程序代码中触发异常

with/as
: 在 Python 2.6 和后续版本中实现环境管理器

## 为什么使用异常

在适当的地方编写代码，响应可能出现的异常，给予编写者一个反馈，以便于查找和修改bug

### 异常的角色

错误处理
: 每当检测到程序错误时，可以在程序代码中捕捉和响应错误，或者忽略已经发生的异常。如果忽略错误，启动默认异常处理行为：停止程序，打印错误信息；如果不想启动默认行为，则需要写 `try` 语句捕捉异常并从异常中恢复：检测到错误后，程序跳到 `try` 处理器，在处理结束后继续执行。

事件通知
: 异常也可以用于发出有效状态的信号，而不需要在程序间传递结果标志位。

特殊情况处理
: 有时可能会发生某种很罕见的情况导致程序错误，此时可以使用异常处理程序处理这种情况，从而省去编写对应该特殊情况的代码。

终止行为
: `try/finally` 可以确保一定会进行需要的结束运算，无论是否有异常。

非常规控制流程
: 异常是一种高级的 `goto`，可以用来实现一些非常规的控制流程，例如反向跟踪（`backtracking`，类似 C语言 中的 `goto`）

## 异常的处理：简明扼要

### 默认异常处理器

当程序出现错误时，Python 会终止程序，并输出错误信息

### 捕获异常

参考 `1、捕获异常.py`

有时，我们更希望在出现错误时，程序处理异常后继续运行，这时需要使用 `try` 语句。

### 引发异常

使用 `raise` 语句，手动引发一个异常。如下面所示（第一个在dos界面运行，使用 `stdin` 标准输出流，第二个在 IDLE 中的结果，使用 `pyshell` 输出）

```Python
raise IndexError
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError

raise IndexError
Traceback (most recent call last):
  File "<pyshell#0>", line 1, in <module>
    raise IndexError
IndexError
```

`assert` 也可以用于触发异常，相当于一个有条件的 `raise`，主要应用于开发过程中的调试。

### 用户定义的异常

用户可以自己定义异常。通过编写一个继承自内置异常类（`Exception`）的类即可。

```Python
class MyException(Exception):
    pass
```

### 终止行为

`try/finally`：定义最后的终止行为，无论是否发生异常，最后一段都会运行。

发生异常后，首先运行 `finally` 中的语句，之后调回去执行 `try` 中的语句（触发异常），参考 `2、终止行为.py`

### 为什么要在意：错误检查

## 本章小结
