# 类的高级主题

## 扩展内置类型

类偶尔会用于扩展 Python 的内置类型，从而支持另类的数据结构或方法

### 通过嵌入扩展类型

参考 `setwrapper.py`

重写一个类，按照自己的需求，重写其中的部分方法
> 如果需要比较复杂的类，该方法的代码量会较大，不建议在复杂类中使用

### 通过子类扩展类型

参考 `typesubclass.py`

直接继承指定的类，根据需要，重写部分方法，**相比上一种方法，建议使用该方法**

## 新式类

在 Python 3.0 中，所有的类都是新式类，都继承自 object，所有的对象都是 object 实例

## 新式类变化

类和类型合并
: 类现在就是类型，使用 `type(X)` 会返回一个实例所创建自的类，通常是和 `X.__class__` 相同

继承搜索顺序
: 先横向搜索再纵向搜索，先宽度优先搜索，再深度优先搜索

针对内置函数的属性获取
: `__getattr__` 和 `__getattribute__` 方法不再针对内置运算的隐式属性获取而运行，即不再针对 `__X__` 运算符重载方法名而调用，这样的名称搜索从类开始，而不是从实例开始

新的高级工具
: 新式类有新的工具，包括 `slot`、特性、描述符和 `__getattribute__` 方法

在第27章简要的介绍了三个变化，将在第37章的属性管理介绍中以及第38章的私有性装饰器介绍中更深入的回顾他们

### 类型模式变化

**1、类即类型**。当使用 `type(X)` 时候，返回结果与 `X.__class__` 相同

通过这种改动，可以比较两个实例是否来自于同一个类
> 在 Python 2.X 中，当使用 `type(X) == tpye(Y)` 比较两个类时，得到的结果均为 `True`，因为所有的 `tpye(X)` 得到的结果都是 `< type 'instance'>`。想要正确比较 Python 2.X 中的两个类，应当使用 `X.__class__ == Y.__class__`

**2、所有对象派生自 object**。类、内置类、实例，都派生自 object

### 钻石继承变动

```Python
class A: attr = 1
class B(A): pass
class C(A): attr = 2
class D(B, C): pass
X = D()
print(X.attr)
```

Python 2.X：按照 **DBAC** 的顺序搜索，搜索到 **A** 时，获取到 `attr`，停止搜索，返回 `attr = 1`

Python 3.X：按照 **DBCA** 的书序搜索，搜索到 **C** 时，获取到 `attr`，停止搜索，返回 `attr = 2`

解决方法一：

```Python
class A: attr = 1
class B(A): pass
class C(A): attr = 2
class D(B, C): attr = B.attr
X = D()
print(X.attr)
```

解决方法二：

```Python
class A:
    def meth(s): print('A meth')
class B(A): pass
class C(A):
    def meth(s): print('C meth')
class D(B, C): pass
X = D()
X.meth()
```

## 新式类的扩展

### slots 实例

将字符串属性名称顺序赋值给特殊的 `__slots__` 类属性，新式类就有可能既限制类的实例将有的合法属性集，又能够优化内存和速度性能，一般在 `class` 语句顶层内进行定义。

* `__slots__` 属性无法进行动态修改（无法通过 `instance.__slots__ = value` 之类的语句进行赋值或修改）
* `__slots__` 会限制实例创建规定以外的属性
* `__slots__` 不会限制类自行增加的属性
* `__slots__` 无法继承到子类

```Python
class Test(object):
    __slots__ = ['age', 'name', 'job']
    __slots__ = ('age', 'name', 'job')
```

### 类特性

**特性（property）**提供了另一种方式让新式类定义自动调用的方法，用于读取或赋值实例属性

是 `__getattr__` 和 `__setattr__` 重载方法的替代做法，特性与这两种方法类似，但是只会在读取所需要的动态计算的变量名时，才会发生额外的方法调用。

特性一般在 `class` 语句的顶层赋值（如 `name = property(...)`）。这样赋值时，对类属性本身的读取，就会自动传给 `property` 一个读取方法。

更高级的用法，参照**第37章**：使用**函数装饰器**语法来编写特性

`property` 函数的语法：

```Python
property([fget[, fset[, fdel[, doc]]]])
```

* fget -- 获取属性值的函数
* fset -- 设置属性值的函数
* fdel -- 删除属性值的函数
* doc  -- 属性描述信息

### \_\_getattribute__ 和描述符

`__getattribute__` 方法**只适用于新式类**，可以拦截所有属性的引用，而不局限于未定义的引用（如 `__getattr__`）
注：该方法比 `__getattr__` 和 `__setattr__` 要难用

除了特性和运算符重载，Python 还支持属性**描述符**的概念：带有 `__get__`、`__set__` 或 `__delete__` 方法的类，分配给类属性并且由实例继承，这拦截了对特定属性的读取和写入访问。

使用方法：

```Python
__get__(self, instance, owner)
__set__(self, instance, value)
__del__(self, instance)
```

描述符与特性：描述符在某种意义上是特性的一种更加通用的形式；特性是定义特定类型描述符的一种简化方式，该描述符运行关于访问的函数。

描述符还可以实现 `slots` 特性

更加详细的讲解，详见**第37章**

### 元类

元类
: 元类是子类化了type对象并且拦截类创建调用的类；元类还为管理和扩展类对象提供了一种定义良好的钩子

具体讲解，详见第39章

## 静态方法和类方法

静态方法和类方法，**只对经典类有效**

### 为什么使用特殊方法

静态方法：程序可能会需要处理一个类，而不是处理实例，此时需要使用到静态方法

类 方 法：传递给该方法的第一个参数是一个类，而不是一个实例

### Python 2.6 和 Python 3.0 中的静态方法

详见 `静态方法替代方案.py`

Python 2.x 中，总是需要传入一个实例对象（通过类/实例调用一个不含 `self` 的方法，会报错）

Python 3.x 中，只有当一个方法的参数列表中有实例（`self`）时，才需要传入一个实例对象
> 如果一个方法中不存在 self 参数，则该方法为静态方法

### 静态方法替代方案

在类外部定义一个方法，对类中的数据进行处理
: > 见 `静态方法替代方案.py` 中第二个例子

在类内部定义一个包含 `self` 参数的方法
: > 见 `静态方法替代方案.py` 中第三个例子

### 使用静态和类方法

详见 `static class.py`

除了 `静态方法替代方案.py` 中的三种方法外，还有另一个选择：使用 **staticmethod** 和 **classmethod** 来编写静态方法和类方法。

静态方法
: 使用 `staticmethod()` 函数转换或使用 `@staticmethod` 装饰器修饰，且不带 `self` 参数的方法。可以直接使用类名调用，也可以通过实例调用。更适合针对处理一个类本地的数据。

类方法
: 使用 `classmethod()` 函数转换或使用 `@classmethod` 装饰器修饰，默认带一个 `cls` 参数，`cls` 表示类，即可以通过 `cls.attribute` 调用类中的方法或属性，相比静态方法，当类名变化时，该指代依然有效。可以被类和对象调用。类方法总是接收一个实例树中最低的一个类，更适合针对处理类层级中每个类的不同数据。

普通（实例）方法
: 默认有个 `self` 参数，且只能被对象调用

### 使用静态方法统计实例

详见 `numInstance.py`

### 使用类方法统计实例

详见 `numInstance.py`

## 装饰器和元类：第一部分

函数装饰器
: 替函数明确特定的运算方式，也就是将函数包裹了另外一层，在另一函数的逻辑内实现。

上一章使用到的 `@staticmethod` 与 `@classmethod` 都是函数装饰器。

函数装饰器类似于**第30章**讨论的**委托**设计模式，但是其设计师为了增强特定的函数或方法调用，而不是整个对象接口。

### 函数装饰器基础

函数装饰器是他后边的函数运行时的声明，装饰器写在定义函数或方法的 `def` 语句的前一行，由 `@` 符号与**元函数**组成。
> 元函数：管理另一个（或其他可调用对象）的函数

### 装饰器例子

参考 `装饰器例子1.py`

当调用 `spam` 函数时，实际触发的是 `tracer` 中的 `__call__` 方法，该方法会计算和记录本次调用，然后委托给原始的包裹的函数。每次调用时，第一行输出来自 `tracer` 类，第二行输出来自 `spam` 方法。

### 类装饰器和元类
TODO: 840
### 更多详细信息

## 类陷阱

### 修改类属性的副作用

### 修改可变的类的属性也可能产生副作用

### 多重继承：顺序很重要

### 类、方法及嵌套作用域

### Python 中基于委托的类：\_\_getattr__ 和内置函数

### “过度包装”

## 本章小结
